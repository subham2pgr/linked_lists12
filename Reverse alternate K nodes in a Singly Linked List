Given a linked list, write a function to reverse every alternate k nodes (where k is an input to the function) in an efficient way. Give the complexity of your algorithm.

Example:

Inputs:   1->2->3->4->5->6->7->8->9->NULL and k = 3
Output:   3->2->1->4->5->6->9->8->7->NULL. 
Recommended: Please try your approach on {IDE} first, before moving on to the solution.
Method 1 (Process 2k nodes and recursively call for rest of the list)
This method is basically an extension of the method discussed in this post.

kAltReverse(struct node *head, int k)
  1)  Reverse first k nodes.
  2)  In the modified list head points to the kth node.  So change next 
       of head to (k+1)th node
  3)  Move the current pointer to skip next k nodes.
  4)  Call the kAltReverse() recursively for rest of the n - 2k nodes.
  5)  Return new head of the list.
filter_none
edit
play_arrow

brightness_4
// C++ program to reverse alternate 
// k nodes in a linked list 
#include <bits/stdc++.h> 
using namespace std; 
  
/* Link list node */
class Node  
{  
    public: 
    int data;  
    Node* next;  
};  
  
/* Reverses alternate k nodes and  
returns the pointer to the new head node */
Node *kAltReverse(Node *head, int k)  
{  
    Node* current = head;  
    Node* next;  
    Node* prev = NULL;  
    int count = 0;  
  
    /*1) reverse first k nodes of the linked list */
    while (current != NULL && count < k)  
    {  
    next = current->next;  
    current->next = prev;  
    prev = current;  
    current = next;  
    count++;  
    }  
      
    /* 2) Now head points to the kth node.  
    So change next  of head to (k+1)th node*/
    if(head != NULL)  
    head->next = current;  
  
    /* 3) We do not want to reverse next k  
       nodes. So move the current  
        pointer to skip next k nodes */
    count = 0;  
    while(count < k-1 && current != NULL )  
    {  
    current = current->next;  
    count++;  
    }  
  
    /* 4) Recursively call for the list  
    starting from current->next. And make 
    rest of the list as next of first node */
    if(current != NULL)  
    current->next = kAltReverse(current->next, k);  
  
    /* 5) prev is new head of the input list */
    return prev;  
}  
  
/* UTILITY FUNCTIONS */
/* Function to push a node */
void push(Node** head_ref, int new_data)  
{  
    /* allocate node */
    Node* new_node = new Node(); 
  
    /* put in the data */
    new_node->data = new_data;  
  
    /* link the old list off the new node */
    new_node->next = (*head_ref);      
  
    /* move the head to point to the new node */
    (*head_ref) = new_node;  
}  
  
/* Function to print linked list */
void printList(Node *node)  
{  
    int count = 0;  
    while(node != NULL)  
    {  
        cout<<node->data<<" ";  
        node = node->next;  
        count++;  
    }  
}  
  
/* Driver code*/
int main(void)  
{  
    /* Start with the empty list */
    Node* head = NULL;  
    int i;  
      
    // create a list 1->2->3->4->5...... ->20  
    for(i = 20; i > 0; i--)  
    push(&head, i);  
  
    cout<<"Given linked list \n";  
    printList(head);  
    head = kAltReverse(head, 3);  
  
    cout<<"\n Modified Linked list \n";  
    printList(head);  
    return(0);  
}  
  
  
// This code is contributed by rathbhupendra 
Output:

Given linked list
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
Modified Linked list
3 2 1 4 5 6 9 8 7 10 11 12 15 14 13 16 17 18 20 19
Time Complexity: O(n)
